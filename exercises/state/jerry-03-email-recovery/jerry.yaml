# Jerry-03: Email Recovery
# Jerry Track - State Management Chaos

metadata:
  exercise_id: jerry-03-email-recovery
  title: "Email Recovery"
  track: jerry
  category: state
  difficulty: intermediate
  estimated_time: 30min

  exam_objectives:
    - "6a: Describe local backend and state file"
    - "6c: Configure remote state storage"
    - "6d: Describe effect of Terraform refresh on state"
    - "7b: Use terraform state commands"

  learning_objectives:
    - "Understand state file structure and contents"
    - "Learn state recovery using terraform state push"
    - "Practice verifying state against real infrastructure"
    - "Migrate from local to remote backend"
    - "Use terraform import as a recovery fallback"
    - "Understand why local state is dangerous"

  tags:
    - state-files
    - disaster-recovery
    - state-push
    - state-import
    - remote-backend
    - s3-backend
    - state-management

scenario:
  description: |
    Jerry was managing production AWS infrastructure with local state from his laptop.
    His hard drive died catastrophically, losing the state file. Fortunately, Jerry
    had emailed himself a backup of terraform.tfstate last week. The AWS resources
    still exist, but Terraform doesn't know about them without the state file.

    This exercise teaches state recovery and why remote backends are essential.

  what_jerry_did:
    - "Created S3 infrastructure using Terraform with local backend"
    - "Emailed himself terraform.tfstate as a 'backup'"
    - "Continued working without setting up remote backend"
    - "Laptop hard drive failed completely"
    - "Infrastructure exists in AWS but state is lost"

  what_students_learn:
    - "State files ARE Terraform's memory of managed resources"
    - "Without state, Terraform doesn't know about existing infrastructure"
    - "Local state is a single point of failure"
    - "terraform state push can recover from state file backups"
    - "Remote backends with versioning prevent these disasters"
    - "terraform import can rebuild state from existing resources"

  unique_aspects:
    - "State file is PROVIDED (not generated by jerry-ctl)"
    - "simulate-jerry.sh creates AWS resources that match the provided state"
    - "Students must understand state file structure"
    - "Multiple valid recovery methods"
    - "Emphasizes prevention (remote backends) over recovery"

# NOTE: This exercise does NOT use jerry-ctl for chaos injection
# Instead, it provides a state file directly and simulates the disaster
# by creating AWS resources that match the state file

infrastructure:
  resources:
    - type: aws_s3_bucket
      name: important_data
      description: "S3 bucket Jerry was managing"

    - type: aws_s3_bucket_versioning
      name: important_data
      description: "Versioning configuration for the bucket"

  provided_files:
    - jerry-backup.tfstate  # The key file - Jerry's emailed backup

recovery_methods:
  method_a:
    name: "State Push"
    difficulty: easy
    description: "Use terraform state push to restore Jerry's backup"
    commands:
      - terraform init
      - terraform state push jerry-backup.tfstate
      - terraform plan

  method_b:
    name: "Migrate to S3 Backend"
    difficulty: medium
    description: "Recover state then migrate to proper S3 backend"
    commands:
      - terraform init
      - terraform state push jerry-backup.tfstate
      - "# Add S3 backend configuration"
      - terraform init -migrate-state
      - terraform plan

  method_c:
    name: "Import from Scratch"
    difficulty: hard
    description: "Rebuild state using terraform import (if state is corrupted)"
    commands:
      - terraform init
      - terraform import aws_s3_bucket.important_data <bucket-name>
      - terraform import aws_s3_bucket_versioning.important_data <bucket-name>
      - terraform plan

validation:
  checks:
    - name: "State file exists and is not empty"
      description: "Student has recovered the state file"

    - name: "State contains correct resources"
      description: "State tracks aws_s3_bucket and aws_s3_bucket_versioning"

    - name: "terraform plan shows no changes"
      description: "State matches actual AWS infrastructure"

    - name: "Resources in state match AWS reality"
      description: "Bucket exists in AWS with correct configuration"

discussion_points:
  - "Why is local state dangerous in production environments?"
  - "What if Jerry's backup was older than the actual infrastructure?"
  - "How do remote backends solve this problem?"
  - "What's the difference between state and configuration?"
  - "When would you use terraform import instead of state push?"
  - "What metadata does a state file contain and why?"

real_world_scenarios:
  - "Consultant leaves with state file on laptop"
  - "Developer 'testing locally' that becomes production"
  - "Legacy project without backend configuration"
  - "Laptop theft or hardware failure"
  - "Accidental state file deletion"
  - "Multiple team members with conflicting local state"

prevention:
  best_practices:
    - "Always use remote backends (S3, Terraform Cloud, etc.)"
    - "Enable versioning on state storage"
    - "Never work from production on personal laptops"
    - "Use state locking to prevent concurrent modifications"
    - "Implement proper access controls on state files"
    - "Regular state backups (though remote backend is better)"

hints:
  - level: 1
    hint: "Run terraform plan with no state - what happens?"

  - level: 2
    hint: "Examine jerry-backup.tfstate structure with jq or cat"

  - level: 3
    hint: "Verify resources exist in AWS using aws s3api or console"

  - level: 4
    hint: "Look up the terraform state push command"

  - level: 5
    hint: "terraform init then terraform state push jerry-backup.tfstate"

  - level: 6
    hint: "After recovery, add S3 backend and run terraform init -migrate-state"

  - level: 7
    hint: "If state push fails, use terraform import as fallback"

going_further:
  - "Experiment with terraform state show and terraform state list"
  - "Compare state files before and after a change"
  - "Set up S3 backend with DynamoDB locking"
  - "Test state recovery with corrupted state file"
  - "Practice terraform state mv and terraform state rm"
